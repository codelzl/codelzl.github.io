<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[solidity队列和数组实现]]></title>
    <url>%2F2019%2F08%2F29%2Fsolidity%E9%98%9F%E5%88%97%E5%92%8C%E6%95%B0%E7%BB%84%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[solidity实现队列和数组。结构体存储 uint[] bytes[] 类型 ，输入参数为string类型。 实现传入string字符串到队列，只将队列中不存在的插入队尾，并且当队列满时丢弃队首。 实现数组增删查改。 tips：输入测试例string类型时 如 “sb12” 记得加引号 1.1 队列的实现 结构体内存储为bytes[] 输入为string1234567891011121314151617181920212223242526272829303132333435363738394041424344454647 //pragma solidity ^0.4.15; contract queue&#123; struct Queue &#123; bytes[] data; uint front; uint rear; &#125; // push function push(Queue storage q, bytes data) internal &#123; if ((q.rear + 1) % q.data.length == q.front) pop(q); // throw first; q.data[q.rear] = data; q.rear = (q.rear + 1) % q.data.length; &#125; // pop function pop(Queue storage q) internal returns (string d) &#123; if (q.rear == q.front) return; // throw; bytes r = q.data[q.front]; d=string(r); delete q.data[q.front]; q.front = (q.front + 1) % q.data.length; &#125;&#125; contract QueueMain is queue &#123; Queue requests; function QueueMain() &#123; requests.data.length = 5;//队列长度 &#125; function addRequest(string d) &#123; push(requests, bytes(d)); &#125; function popRequest() returns (string) &#123; return pop(requests); &#125; &#125; 1.2 队列的实现 结构体内存储为uint[] 输入为uint12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152 //pragma solidity ^0.4.15; contract queue&#123; struct Queue &#123; uint[] data; uint front; uint rear; &#125; // Queue length function length(Queue storage q) constant internal returns (uint) &#123; return q.rear - q.front; &#125; // push function push(Queue storage q, uint data) internal &#123; if ((q.rear + 1) % q.data.length == q.front) pop(q); // throw first; q.data[q.rear] = data; q.rear = (q.rear + 1) % q.data.length; &#125; // pop function pop(Queue storage q) internal returns (uint r) &#123; if (q.rear == q.front) return; // throw; r = q.data[q.front]; delete q.data[q.front]; q.front = (q.front + 1) % q.data.length; &#125;&#125; contract QueueMain is queue &#123; Queue requests; function QueueMain() &#123; requests.data.length = 5; &#125; function addRequest(uint d) &#123; push(requests, d); &#125; function popRequest() returns (uint) &#123; return pop(requests); &#125; function queueLength() returns (uint) &#123; return length(requests); &#125; &#125; 1.3 队列的实现 结构体内存储为bytes[] 输入为string1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677 /*pragma solidity ^0.4.15;实现一个队列传入string类型的参数：通过keccak256()比较该string字符串是否在队列当中存在 存在：丢弃 不存在：加入队列尾，当队列满时将队首丢弃*/ contract queue&#123; struct Queue &#123; bytes[] data; uint front; uint rear; &#125; // push function push(Queue storage q, bytes data) internal &#123; if ((q.rear + 1) % q.data.length == q.front) pop(q); // throw first; q.data[q.rear] = data; q.rear = (q.rear + 1) % q.data.length; &#125; // Queue length function length(Queue storage q) constant internal returns (uint) &#123; return q.rear - q.front; &#125; // pop function pop(Queue storage q) internal returns (string d) &#123; if (q.rear == q.front) return; // throw; bytes r = q.data[q.front]; d=string(r); delete q.data[q.front]; q.front = (q.front + 1) % q.data.length; &#125; &#125; contract QueueMain is queue &#123; Queue requests; function QueueMain() &#123; requests.data.length = 5;//控制队列长度 &#125; //put in string(_tx_hash) function addRequest(string d) returns(string) &#123; for( uint i= requests.front; i&lt;requests.rear+1; i++)&#123; if(keccak256(string(requests.data[i]))==keccak256(d)) &#123; // length(requests); return "have exist"; &#125; &#125; if(keccak256(string(requests.data[i]))!=keccak256(d))&#123; push(requests, bytes(d)); return"ojbk"; &#125; &#125; function popRequest() returns (string) &#123; return pop(requests); &#125; function queueLength() returns (uint) &#123; return length(requests); &#125; &#125; 1.4 数组增删查改实现123456789101112131415161718192021222324252627282930313233343536373839404142//pragma solidity 0.4.20;contract testArray &#123; //全局数组变量 string[] public strArr; //构造函数，数组中添加字符abc function testArray() public&#123; strArr.push("abc"); &#125; //增 function Add(string str) &#123; strArr.push(str); &#125; //删 function delByIndex(uint _index)&#123; uint len = strArr.length; if (_index &gt; len) return; for (uint i = _index; i&lt;len-1; i++)&#123; strArr[i] = strArr[i+1]; &#125; delete strArr[len-1]; strArr.length--; &#125; //查 数组索引 function valueByIndex(uint _index) returns (string _value)&#123; if (_index &gt; strArr.length-1) throw; return strArr[_index]; &#125; //改 数组索引，修改后的值 function update(uint _index, string _value)&#123; if (_index &gt; strArr.length-1) throw; strArr[_index] = _value; &#125; &#125;]]></content>
      <categories>
        <category>solidity</category>
      </categories>
      <tags>
        <tag>队列</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[solidity投票智能合约remix部署]]></title>
    <url>%2F2019%2F08%2F29%2Fsolidity%E6%8A%95%E7%A5%A8%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6remix%E9%83%A8%E7%BD%B2%2F</url>
    <content type="text"><![CDATA[solidity的投票示例以及其在remix上部署测试 1.solidity投票实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128pragma solidity &gt;=0.4.22 &lt;0.7.0;/// @title 委托投票contract Ballot &#123; // 这里声明了一个新的复合类型用于稍后的变量 // 它用来表示一个选民 struct Voter &#123; uint weight; // 计票的权重 bool voted; // 若为真，代表该人已投票 address delegate; // 被委托人 uint vote; // 投票提案的索引 &#125; // 提案的类型 struct Proposal &#123; bytes32 name; // 简称（最长32个字节） uint voteCount; // 得票数 &#125; address public chairperson; // 这声明了一个状态变量，为每个可能的地址存储一个 `Voter`。 mapping(address =&gt; Voter) public voters; // 一个 `Proposal` 结构类型的动态数组 Proposal[] public proposals; /// 为 `proposalNames` 中的每个提案，创建一个新的（投票）表决 constructor(bytes32[] memory proposalNames) public &#123; chairperson = msg.sender; voters[chairperson].weight = 1; //对于提供的每个提案名称， //创建一个新的 Proposal 对象并把它添加到数组的末尾。 for (uint i = 0; i &lt; proposalNames.length; i++) &#123; // `Proposal(&#123;...&#125;)` 创建一个临时 Proposal 对象， // `proposals.push(...)` 将其添加到 `proposals` 的末尾 proposals.push(Proposal(&#123; name: proposalNames[i], voteCount: 0 &#125;)); &#125; &#125; // 授权 `voter` 对这个（投票）表决进行投票 // 只有 `chairperson` 可以调用该函数。 function giveRightToVote(address voter) public &#123; // 若 `require` 的第一个参数的计算结果为 `false`， // 则终止执行，撤销所有对状态和以太币余额的改动。 // 在旧版的 EVM 中这曾经会消耗所有 gas，但现在不会了。 // 使用 require 来检查函数是否被正确地调用，是一个好习惯。 // 你也可以在 require 的第二个参数中提供一个对错误情况的解释。 require( msg.sender == chairperson, "Only chairperson can give right to vote." ); require( !voters[voter].voted, "The voter already voted." ); require(voters[voter].weight == 0); voters[voter].weight = 1; &#125; /// 把你的投票委托到投票者 `to`。 function delegate(address to) public &#123; // 传引用 Voter storage sender = voters[msg.sender]; require(!sender.voted, "You already voted."); require(to != msg.sender, "Self-delegation is disallowed."); // 委托是可以传递的，只要被委托者 `to` 也设置了委托。 // 一般来说，这种循环委托是危险的。因为，如果传递的链条太长， // 则可能需消耗的gas要多于区块中剩余的（大于区块设置的gasLimit）， // 这种情况下，委托不会被执行。 // 而在另一些情况下，如果形成闭环，则会让合约完全卡住。 while (voters[to].delegate != address(0)) &#123; to = voters[to].delegate; // 不允许闭环委托 require(to != msg.sender, "Found loop in delegation."); &#125; // `sender` 是一个引用, 相当于对 `voters[msg.sender].voted` 进行修改 sender.voted = true; sender.delegate = to; Voter storage delegate_ = voters[to]; if (delegate_.voted) &#123; // 若被委托者已经投过票了，直接增加得票数 proposals[delegate_.vote].voteCount += sender.weight; &#125; else &#123; // 若被委托者还没投票，增加委托者的权重 delegate_.weight += sender.weight; &#125; &#125; /// 把你的票(包括委托给你的票)， /// 投给提案 `proposals[proposal].name`. function vote(uint proposal) public &#123; Voter storage sender = voters[msg.sender]; require(!sender.voted, "Already voted."); sender.voted = true; sender.vote = proposal; // 如果 `proposal` 超过了数组的范围，则会自动抛出异常，并恢复所有的改动 proposals[proposal].voteCount += sender.weight; &#125; /// @dev 结合之前所有的投票，计算出最终胜出的提案 function winningProposal() public view returns (uint winningProposal_) &#123; uint winningVoteCount = 0; for (uint p = 0; p &lt; proposals.length; p++) &#123; if (proposals[p].voteCount &gt; winningVoteCount) &#123; winningVoteCount = proposals[p].voteCount; winningProposal_ = p; &#125; &#125; &#125; // 调用 winningProposal() 函数以获取提案数组中获胜者的索引，并以此返回获胜者的名称 function winnerName() public view returns (bytes32 winnerName_) &#123; winnerName_ = proposals[winningProposal()].name; &#125;&#125; 2.remix下调试2.1构造函数deploy时输入构造函数的参数12345[&quot;0xd4967590eb024589dfb6b9e48a576eb49ebc19d764b0d1d67dc21975e7258e97&quot;,&quot;0x0000000000000000000000000000000000000000000000000000000000000001&quot;,&quot;0x0000000000000000000000000000000000000000000000000000000000000002&quot;,&quot;0x0000000000000000000000000000000000000000000000000000000000000003&quot;,&quot;0x065e0be95fb43db528a20ba65c0e575e33cd4a9e1ca089dba4efff24596e8553&quot;] 2.2deploy后合约函数说明 对应地址为如下所示账户地址 其中部署合约地址为0xca35b7d915458ef540ade6068dfe2f44e8fa733c chairperson 获取当前提案创建者为0xca35b7d915458ef540ade6068dfe2f44e8fa733c delegate委托投票，将自己投票权给其他address。此时需切换上方account进行委托 giveRightToVote 授权投票 只有chairperson可以进行调用 vote给某个提案投票]]></content>
      <categories>
        <category>solidity</category>
      </categories>
      <tags>
        <tag>remix</tag>
        <tag>solidity_voting</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[typora使用]]></title>
    <url>%2F2019%2F08%2F29%2Ftypora%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[typora的安装以及简单使用教程 1.安装Typora官网下载地址：https://typora.io/pandoc下载地址：http://pandoc.org/installing.html 2.使用（1）标题标题是用“#”实现的，标题前面加一个“#”，代表一级标题；依次类推，标题前面加六个“#”代表六级标题；一共有六级标题，编辑各种文档完全够用。 （2）下划线快捷键Ctrl+u,即可实现下划线功能。 （3）强调在要强调内容前后分别加两个“*”号。 （4）斜体内容前后分别加一个“*”号。 （5）删除线先转化成英文输入法，再把内容前后分别加上两个“~”号。 （6）高亮内容前后分别加两个“=”。 （7）列表/表格 有序列表:输入数字“1”+“.”+空格 ， 自动开始有序列表。 无序列表:输入“+”或“-”或“*”+空格，自动开始无序列表。 Ctrl+T,在弹出的对话框中选择行列数，自动生成列表。 （8）分割线输入三个或三个以上“-”（“*”），再按回车键，即出现一条分割线。 （9）插入 图片插入本地图片：直接把图片拖入即可；插入网络图片：推荐安利微博图床！Chrome扩展即可 链接[链接提示]+(链接地址)。 -数学公式 “$$”+回车。 代码行内代码：代码的两端各加一个“`”号，（在Tab键上面，英文输入法）。代码块：输入三个“~”，按回车键，即可选择编程语言。 微信公众号关注我们，精彩文章不错过]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>typora</tag>
      </tags>
  </entry>
</search>
