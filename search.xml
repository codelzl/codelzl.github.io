<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[跨链项目部署]]></title>
    <url>%2F2019%2F12%2F10%2F%E8%B7%A8%E9%93%BE%E9%A1%B9%E7%9B%AE%E9%83%A8%E7%BD%B2%2F</url>
    <content type="text"></content>
      <categories>
        <category>区块链跨链</category>
      </categories>
      <tags>
        <tag>跨链</tag>
        <tag>bu链</tag>
        <tag>以太坊</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[solidity——spv资料]]></title>
    <url>%2F2019%2F10%2F29%2Fsolidity%E2%80%94%E2%80%94spv%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[1.树根哈希以太坊节点中是key-value格式的数据存储格式 Node=(Key,Value) value就是节点的RLP编码，key则是RLP编码的哈希值。 2.ABI编码 ABI 全称是 Application Binary Interface，翻译过来就是：应用程序二进制接口，简单来说就是 以太坊的调用合约时的接口说明。 以太坊的外部应用程序向以太坊网络提交交易。 合约功能实际上是将交易提交到合约地址（帐户）。 交易有其他数据， 附加数据是ABI编码数据。 编码数据后长度取决于之前定义类型 例子 https://ethereum.stackexchange.com/questions/59149/abi-encodepacked-with-lot-of-zeros 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354package mainimport "fmt"import "crypto/sha256"import "bytes"func main() &#123; fmt.Printf("%s\n", "hello world")&#125;// Hash256 implements bitcoin's hash256 (double sha2)func Hash256(in []byte) []byte &#123; first := sha256.Sum256(in) second := sha256.Sum256(first[:]) return second[:]&#125;func hash256MerkleStep(a []byte, b []byte) []byte &#123; c := []byte&#123;&#125; c = append(c, a...) c = append(c, b...) return Hash256(c)&#125;// VerifyHash256Merkle checks a merkle inclusion proof's validityfunc VerifyHash256Merkle(proof []byte, index uint) bool &#123; idx := index proofLength := len(proof) if proofLength%32 != 0 &#123; return false &#125; if proofLength == 32 &#123; return true &#125; if proofLength == 64 &#123; return false &#125; root := proof[proofLength-32:] current := proof[:32] numSteps := (proofLength / 32) - 1 for i := 1; i &lt; numSteps; i++ &#123; next := proof[i*32 : i*32+32] if idx%2 == 1 &#123; current = hash256MerkleStep(next, current) &#125; else &#123; current = hash256MerkleStep(current, next) &#125; idx &gt;&gt;= 1 &#125; return bytes.Equal(current, root)&#125; 3.summa思路btc 2 eth https://github.com/summa-tx/bitcoin-spv （1） BTC交易输入输出是否存在。通过智能合约判断是否是伪造的交易 （2）判断交易是否在区块内。merkle包含证明 （3）区块头的验证。 检查每个块是否都引用了前一个块，然后计算用于制作该链的总工作量证明。 https://medium.com/summa-technology/cross-chain-auction-technical-f16710bfe69f 4.实现问题（1） Ethash 工作量证明内存需求大–&gt; 基于以太坊智能合约的现有加密货币的高效分散式矿池。 smartpool （2） Patricia Merkle tree –&gt; The merkle-patricia-proof tool]]></content>
      <categories>
        <category>solidity</category>
      </categories>
      <tags>
        <tag>spv</tag>
        <tag>merkle树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue跨域问题解决]]></title>
    <url>%2F2019%2F10%2F29%2Fvue%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[1.vue模板 script部分 export default { name: "Home", data() { return {}; }, methods: { // 组件的方法 }, watch: { // watch擅长处理的场景：一个数据影响多个数据 }, computed: { // computed擅长处理的场景：一个数据受多个数据影响 }, beforeCreate: function() { // 在实例初始化之后，数据观测(data observer) 和 event/watcher 事件配置之前被调用。 }, created: function() { // 实例已经创建完成之后被调用。在这一步，实例已完成以下的配置：数据观测(data observer)，属性和方法的运算， watch/event 事件回调。然而，挂载阶段还没开始，$el 属性目前不可见。 }, beforeMount: function() { // 在挂载开始之前被调用：相关的 render 函数首次被调用。 }, mounted: function() { // 编译好的HTML挂载到页面完成后执行的事件钩子 // el 被新创建的 vm.$el 替换，并挂载到实例上去之后调用该钩子。 // 此钩子函数中一般会做一些ajax请求获取数据进行数据初始化 console.log("Home done"); }, beforeUpdate: function() { // 数据更新时调用，发生在虚拟 DOM 重新渲染和打补丁之前。 你可以在这个钩子中进一步地更改状态，这不会触发附加的重渲染过程。 }, updated: function() { // 由于数据更改导致的虚拟 DOM 重新渲染和打补丁，在这之后会调用该钩子。 // 当这个钩子被调用时，组件 DOM 已经更新，所以你现在可以执行依赖于 DOM 的操作。然而在大多数情况下，你应该避免在此期间更改状态，因为这可能会导致更新无限循环。 // 该钩子在服务器端渲染期间不被调用。 }, beforeDestroy: function() { // 实例销毁之前调用。在这一步，实例仍然完全可用。 }, destroyed: function() { // Vue 实例销毁后调用。调用后，Vue 实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。 该钩子在服务器端渲染期间不被调用。 } }; 2.跨域问题解决 bumo区块链]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>跨域</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[判断是否为合约地址]]></title>
    <url>%2F2019%2F09%2F02%2F%E5%88%A4%E6%96%AD%E6%98%AF%E5%90%A6%E4%B8%BA%E5%90%88%E7%BA%A6%E5%9C%B0%E5%9D%80%2F</url>
    <content type="text"><![CDATA[判断一个地址是否为合约地址或是外部账户地址 extcodesize 获取地址关联代码长度。 合约地址长度大于0， 外部账户地址为0 1234567891011//pragma solidity ^0.4.18;//extcodesize获取地址关联代码长度 合约地址大于0 外部账户地址为0 contract IsCadd &#123; function isContract(address addr) returns (bool) &#123; uint size; assembly &#123; size := extcodesize(addr) &#125; return size &gt; 0; &#125;&#125;]]></content>
      <categories>
        <category>solidity</category>
      </categories>
      <tags>
        <tag>合约地址判断</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[实现可升级智能合约]]></title>
    <url>%2F2019%2F08%2F30%2F%E5%AE%9E%E7%8E%B0%E5%8F%AF%E5%8D%87%E7%BA%A7%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6%2F</url>
    <content type="text"><![CDATA[智能合约升级的基本思路以及具体简单demo实现 1.智能合约可升级性智能合约一旦部署无法进行修改，常见方案 1.1 主从合约Master-Slave contracts 部署一个主合约，以及其他合约，其中主合约负责存储所有其他合约的地址，并在需要时返回所需的地址。 优点：简单 缺点：不易进行合约资产转移到新合约 1.2永久存储合约Eternal Storage contracts 逻辑合约和数据合约彼此分开。 数据合约是永久性的，不可升级。 逻辑合约可以根据需要多次升级，并将更改通知给数据合约。通常会和主从技术相结合。 缺点：数据合约不可更改、逻辑合约外部调用数据合约消耗gas 1.3 可升级存储代理合约Upgradable Storage Proxy Contracts 代理合约以及逻辑合约，将继承同一存储合约。 代理合约将有一个回退函数，委托调用逻辑合约，从而实现逻辑合约在代理存储中进行更改。 1.4委托调用EVM所提供的DELEGATECALL操作码，DELEGATECALL就像是一个普通的CALL 调用操作码，不同之处在于目标地址上的代码是在调用合约上下文中执行的，而原始调用的msg.sender以及msg.value将被保留。 分离逻辑和数据合约逻辑合约通过setter更新数据，而数据合约只允许逻辑合约调用setter。这允许在保持数据不变的同时更换实现逻辑，从而实现完全可升级的系统。 通过引导用户使用新的逻辑合约（通过诸如ENS的解析器）并更新数据合约的权限来允许新的逻辑合约执行setter，就可以实现合约的更新。 键值对数据模型分离逻辑和数据合约不使用最终期望数据结构（struct，mapping等）来定义合约数据模型，所有数据都被抽象化并存储在键值对中，然后使用一个标准的命名系统以及sha256散列算法用于查找数据值。 2.实现DEMOstorage 存储 implementionV1 原智能合约 implementionV2 新智能合约 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687//0.4.25contract StorageStructure &#123; address public implementation; address public owner; mapping (address =&gt; uint) internal points; uint internal totalPlayers;&#125;contract Proxy is StorageStructure &#123; //确保只有所有者可以运行这个函数 modifier onlyOwner() &#123; require (msg.sender == owner); _; &#125; //设置管理者owner地址 constructor() public &#123; owner = msg.sender; &#125; //更新实现合约地址 function upgradeTo(address _newImplementation) external onlyOwner &#123; require(implementation != _newImplementation); _setImplementation(_newImplementation); &#125; //回调 function () payable public &#123; address impl = implementation; require(impl != address(0)); assembly &#123; let ptr := mload(0x40) calldatacopy(ptr, 0, calldatasize) let result := delegatecall(gas, impl, ptr, calldatasize, 0, 0) let size := returndatasize returndatacopy(ptr, 0, size) switch result case 0 &#123; revert(ptr, size) &#125; default &#123; return(ptr, size) &#125; &#125; &#125; //设置当前实现地址 function _setImplementation(address _newImp) internal &#123; implementation = _newImp; &#125;&#125;contract ImplementationV1 is StorageStructure &#123;modifier onlyOwner() &#123; require (msg.sender == owner); _; &#125; function addPlayer(address _player, uint _points) public onlyOwner &#123; require (points[_player] == 0); points[_player] = _points; &#125; function setPoints(address _player, uint _points) public onlyOwner &#123; require (points[_player] != 0); points[_player] = _points; &#125;&#125;contract ImplementationV2 is ImplementationV1 &#123; function addPlayer(address _player, uint _points) public onlyOwner &#123; require (points[_player] == 0); points[_player] = _points; totalPlayers++; &#125;&#125; 依次部署 proxy合约、ImplementationV1合约 调用proxy合约的upgradeTo(address)函数： address为部署后的implementionV1合约地址。 重新部署 proxy合约，此时只需使用proxy合约即可 合约升级： 重写并部署implementionV2合约 ，并将其合约地址,作为调用proxy合约的upgradeTo(address)参数 相关文章链接 https://hackernoon.com/how-to-make-smart-contracts-upgradable-2612e771d5a2 https://yos.io/2018/10/28/upgrading-solidity-smart-contracts/]]></content>
      <categories>
        <category>solidity</category>
      </categories>
      <tags>
        <tag>智能合约升级</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[solidity队列和数组实现]]></title>
    <url>%2F2019%2F08%2F29%2Fsolidity%E9%98%9F%E5%88%97%E5%92%8C%E6%95%B0%E7%BB%84%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[solidity实现队列和数组。结构体存储 uint[] bytes[] 类型 ，输入参数为string类型。 实现传入string字符串到队列，只将队列中不存在的插入队尾，并且当队列满时丢弃队首。 实现数组增删查改。 tips：输入测试例string类型时 如 “sb12” 记得加引号 1.1 队列的实现 结构体内存储为bytes[] 输入为string1234567891011121314151617181920212223242526272829303132333435363738394041424344454647 //pragma solidity ^0.4.15; contract queue&#123; struct Queue &#123; bytes[] data; uint front; uint rear; &#125; // push function push(Queue storage q, bytes data) internal &#123; if ((q.rear + 1) % q.data.length == q.front) pop(q); // throw first; q.data[q.rear] = data; q.rear = (q.rear + 1) % q.data.length; &#125; // pop function pop(Queue storage q) internal returns (string d) &#123; if (q.rear == q.front) return; // throw; bytes r = q.data[q.front]; d=string(r); delete q.data[q.front]; q.front = (q.front + 1) % q.data.length; &#125;&#125; contract QueueMain is queue &#123; Queue requests; function QueueMain() &#123; requests.data.length = 5;//队列长度 &#125; function addRequest(string d) &#123; push(requests, bytes(d)); &#125; function popRequest() returns (string) &#123; return pop(requests); &#125; &#125; 1.2 队列的实现 结构体内存储为uint[] 输入为uint12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152 //pragma solidity ^0.4.15; contract queue&#123; struct Queue &#123; uint[] data; uint front; uint rear; &#125; // Queue length function length(Queue storage q) constant internal returns (uint) &#123; return q.rear - q.front; &#125; // push function push(Queue storage q, uint data) internal &#123; if ((q.rear + 1) % q.data.length == q.front) pop(q); // throw first; q.data[q.rear] = data; q.rear = (q.rear + 1) % q.data.length; &#125; // pop function pop(Queue storage q) internal returns (uint r) &#123; if (q.rear == q.front) return; // throw; r = q.data[q.front]; delete q.data[q.front]; q.front = (q.front + 1) % q.data.length; &#125;&#125; contract QueueMain is queue &#123; Queue requests; function QueueMain() &#123; requests.data.length = 5; &#125; function addRequest(uint d) &#123; push(requests, d); &#125; function popRequest() returns (uint) &#123; return pop(requests); &#125; function queueLength() returns (uint) &#123; return length(requests); &#125; &#125; 1.3 队列的实现 结构体内存储为bytes[] 输入为string1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677 /*pragma solidity ^0.4.15;实现一个队列传入string类型的参数：通过keccak256()比较该string字符串是否在队列当中存在 存在：丢弃 不存在：加入队列尾，当队列满时将队首丢弃*/ contract queue&#123; struct Queue &#123; bytes[] data; uint front; uint rear; &#125; // push function push(Queue storage q, bytes data) internal &#123; if ((q.rear + 1) % q.data.length == q.front) pop(q); // throw first; q.data[q.rear] = data; q.rear = (q.rear + 1) % q.data.length; &#125; // Queue length function length(Queue storage q) constant internal returns (uint) &#123; return q.rear - q.front; &#125; // pop function pop(Queue storage q) internal returns (string d) &#123; if (q.rear == q.front) return; // throw; bytes r = q.data[q.front]; d=string(r); delete q.data[q.front]; q.front = (q.front + 1) % q.data.length; &#125; &#125; contract QueueMain is queue &#123; Queue requests; function QueueMain() &#123; requests.data.length = 5;//控制队列长度 &#125; //put in string(_tx_hash) function addRequest(string d) returns(string) &#123; for( uint i= requests.front; i&lt;requests.rear+1; i++)&#123; if(keccak256(string(requests.data[i]))==keccak256(d)) &#123; // length(requests); return "have exist"; &#125; &#125; if(keccak256(string(requests.data[i]))!=keccak256(d))&#123; push(requests, bytes(d)); return"ojbk"; &#125; &#125; function popRequest() returns (string) &#123; return pop(requests); &#125; function queueLength() returns (uint) &#123; return length(requests); &#125; &#125; 1.4 数组增删查改实现123456789101112131415161718192021222324252627282930313233343536373839404142//pragma solidity 0.4.20;contract testArray &#123; //全局数组变量 string[] public strArr; //构造函数，数组中添加字符abc function testArray() public&#123; strArr.push("abc"); &#125; //增 function Add(string str) &#123; strArr.push(str); &#125; //删 function delByIndex(uint _index)&#123; uint len = strArr.length; if (_index &gt; len) return; for (uint i = _index; i&lt;len-1; i++)&#123; strArr[i] = strArr[i+1]; &#125; delete strArr[len-1]; strArr.length--; &#125; //查 数组索引 function valueByIndex(uint _index) returns (string _value)&#123; if (_index &gt; strArr.length-1) throw; return strArr[_index]; &#125; //改 数组索引，修改后的值 function update(uint _index, string _value)&#123; if (_index &gt; strArr.length-1) throw; strArr[_index] = _value; &#125; &#125;]]></content>
      <categories>
        <category>solidity</category>
      </categories>
      <tags>
        <tag>队列</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[solidity投票智能合约remix部署]]></title>
    <url>%2F2019%2F08%2F29%2Fsolidity%E6%8A%95%E7%A5%A8%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6remix%E9%83%A8%E7%BD%B2%2F</url>
    <content type="text"><![CDATA[solidity的投票示例以及其在remix上部署测试 1.solidity投票实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128pragma solidity &gt;=0.4.22 &lt;0.7.0;/// @title 委托投票contract Ballot &#123; // 这里声明了一个新的复合类型用于稍后的变量 // 它用来表示一个选民 struct Voter &#123; uint weight; // 计票的权重 bool voted; // 若为真，代表该人已投票 address delegate; // 被委托人 uint vote; // 投票提案的索引 &#125; // 提案的类型 struct Proposal &#123; bytes32 name; // 简称（最长32个字节） uint voteCount; // 得票数 &#125; address public chairperson; // 这声明了一个状态变量，为每个可能的地址存储一个 `Voter`。 mapping(address =&gt; Voter) public voters; // 一个 `Proposal` 结构类型的动态数组 Proposal[] public proposals; /// 为 `proposalNames` 中的每个提案，创建一个新的（投票）表决 constructor(bytes32[] memory proposalNames) public &#123; chairperson = msg.sender; voters[chairperson].weight = 1; //对于提供的每个提案名称， //创建一个新的 Proposal 对象并把它添加到数组的末尾。 for (uint i = 0; i &lt; proposalNames.length; i++) &#123; // `Proposal(&#123;...&#125;)` 创建一个临时 Proposal 对象， // `proposals.push(...)` 将其添加到 `proposals` 的末尾 proposals.push(Proposal(&#123; name: proposalNames[i], voteCount: 0 &#125;)); &#125; &#125; // 授权 `voter` 对这个（投票）表决进行投票 // 只有 `chairperson` 可以调用该函数。 function giveRightToVote(address voter) public &#123; // 若 `require` 的第一个参数的计算结果为 `false`， // 则终止执行，撤销所有对状态和以太币余额的改动。 // 在旧版的 EVM 中这曾经会消耗所有 gas，但现在不会了。 // 使用 require 来检查函数是否被正确地调用，是一个好习惯。 // 你也可以在 require 的第二个参数中提供一个对错误情况的解释。 require( msg.sender == chairperson, "Only chairperson can give right to vote." ); require( !voters[voter].voted, "The voter already voted." ); require(voters[voter].weight == 0); voters[voter].weight = 1; &#125; /// 把你的投票委托到投票者 `to`。 function delegate(address to) public &#123; // 传引用 Voter storage sender = voters[msg.sender]; require(!sender.voted, "You already voted."); require(to != msg.sender, "Self-delegation is disallowed."); // 委托是可以传递的，只要被委托者 `to` 也设置了委托。 // 一般来说，这种循环委托是危险的。因为，如果传递的链条太长， // 则可能需消耗的gas要多于区块中剩余的（大于区块设置的gasLimit）， // 这种情况下，委托不会被执行。 // 而在另一些情况下，如果形成闭环，则会让合约完全卡住。 while (voters[to].delegate != address(0)) &#123; to = voters[to].delegate; // 不允许闭环委托 require(to != msg.sender, "Found loop in delegation."); &#125; // `sender` 是一个引用, 相当于对 `voters[msg.sender].voted` 进行修改 sender.voted = true; sender.delegate = to; Voter storage delegate_ = voters[to]; if (delegate_.voted) &#123; // 若被委托者已经投过票了，直接增加得票数 proposals[delegate_.vote].voteCount += sender.weight; &#125; else &#123; // 若被委托者还没投票，增加委托者的权重 delegate_.weight += sender.weight; &#125; &#125; /// 把你的票(包括委托给你的票)， /// 投给提案 `proposals[proposal].name`. function vote(uint proposal) public &#123; Voter storage sender = voters[msg.sender]; require(!sender.voted, "Already voted."); sender.voted = true; sender.vote = proposal; // 如果 `proposal` 超过了数组的范围，则会自动抛出异常，并恢复所有的改动 proposals[proposal].voteCount += sender.weight; &#125; /// @dev 结合之前所有的投票，计算出最终胜出的提案 function winningProposal() public view returns (uint winningProposal_) &#123; uint winningVoteCount = 0; for (uint p = 0; p &lt; proposals.length; p++) &#123; if (proposals[p].voteCount &gt; winningVoteCount) &#123; winningVoteCount = proposals[p].voteCount; winningProposal_ = p; &#125; &#125; &#125; // 调用 winningProposal() 函数以获取提案数组中获胜者的索引，并以此返回获胜者的名称 function winnerName() public view returns (bytes32 winnerName_) &#123; winnerName_ = proposals[winningProposal()].name; &#125;&#125; 2.remix下调试2.1构造函数deploy时输入构造函数的参数12345[&quot;0xd4967590eb024589dfb6b9e48a576eb49ebc19d764b0d1d67dc21975e7258e97&quot;,&quot;0x0000000000000000000000000000000000000000000000000000000000000001&quot;,&quot;0x0000000000000000000000000000000000000000000000000000000000000002&quot;,&quot;0x0000000000000000000000000000000000000000000000000000000000000003&quot;,&quot;0x065e0be95fb43db528a20ba65c0e575e33cd4a9e1ca089dba4efff24596e8553&quot;] 2.2deploy后合约函数说明 对应地址为如下所示账户地址 其中部署合约地址为0xca35b7d915458ef540ade6068dfe2f44e8fa733c chairperson 获取当前提案创建者为0xca35b7d915458ef540ade6068dfe2f44e8fa733c delegate委托投票，将自己投票权给其他address。此时需切换上方account进行委托 giveRightToVote 授权投票 只有chairperson可以进行调用 vote给某个提案投票]]></content>
      <categories>
        <category>solidity</category>
      </categories>
      <tags>
        <tag>remix</tag>
        <tag>solidity_voting</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[typora使用]]></title>
    <url>%2F2019%2F08%2F29%2Ftypora%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[typora的安装以及简单使用教程 1.安装Typora官网下载地址：https://typora.io/pandoc下载地址：http://pandoc.org/installing.html 2.使用（1）标题标题是用“#”实现的，标题前面加一个“#”，代表一级标题；依次类推，标题前面加六个“#”代表六级标题；一共有六级标题，编辑各种文档完全够用。 （2）下划线快捷键Ctrl+u,即可实现下划线功能。 （3）强调在要强调内容前后分别加两个“*”号。 （4）斜体内容前后分别加一个“*”号。 （5）删除线先转化成英文输入法，再把内容前后分别加上两个“~”号。 （6）高亮内容前后分别加两个“=”。 （7）列表/表格 有序列表:输入数字“1”+“.”+空格 ， 自动开始有序列表。 无序列表:输入“+”或“-”或“*”+空格，自动开始无序列表。 Ctrl+T,在弹出的对话框中选择行列数，自动生成列表。 （8）分割线输入三个或三个以上“-”（“*”），再按回车键，即出现一条分割线。 （9）插入 图片插入本地图片：直接把图片拖入即可；插入网络图片：推荐安利微博图床！Chrome扩展即可 链接[链接提示]+(链接地址)。 -数学公式 “$$”+回车。 代码行内代码：代码的两端各加一个“`”号，（在Tab键上面，英文输入法）。代码块：输入三个“~”，按回车键，即可选择编程语言。 微信公众号关注我们，精彩文章不错过]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>typora</tag>
      </tags>
  </entry>
</search>
